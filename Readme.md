# Kafka Avro Messaging System

Распределенная система обмена данными через кластер Apache Kafka с использованием сериализации **Avro** и автоматического управления схемами через **Reflection**.

 **Команда для запуска:** `docker compose up -d --build`

> **Важно:** Топик создавать вручную не нужно — его автоматически создаст сервис инициализации.
>
> | Топик | Партиция | Брокер (лидер) | Реплики | ISR |
> | :--- | :---: | :---: | :---: | :---: |
> | **test-topic** | 0 | 2 | 2, 0 | 2, 0 |
> | **test-topic** | 1 | 0 | 0, 1 | 0, 1 |
> | **test-topic** | 2 | 1 | 1, 2 | 1, 2 |

## Компоненты системы

1. **MessageDto** (объект передачи данных)
    * Содержит UUID в строковом виде и случайное число.
    * Не требует предварительного описания `.avsc` схемы благодаря Reflection.
    * Kafka-сериализатор автоматически генерирует Avro-схему на основе полей Java-класса.

2. **AvroProducer** (продюсер) — **2 реплики**
    * Каждые 500 мс генерирует и отправляет новое сообщение.
    * Включена идемпотентность (`ENABLE_IDEMPOTENCE_CONFIG`), гарантирующая отсутствие дубликатов.
    * Уровень подтверждения `acks=all` обеспечивает сохранность данных на всех репликах.
    * Бесконечные попытки переотправки при временных сбоях.

3. **AvroSingleConsumer** (одиночный потребитель) — **2 реплики**
    * Обрабатывает сообщения по одному в режиме реального времени.
    * Демонстрирует извлечение метаданных, включая определение ID конкретного брокера-лидера для каждой партиции.
    * Использует автоматический коммит смещений (`enable.auto.commit = true`).

4. **AvroBatchConsumer** (пакетный потребитель) — **2 реплики**
    * Накапливает сообщения во внутреннем буфере до достижения размера батча или истечения тайм-аута.
    * Использует ручной коммит (`commitSync`) — смещения фиксируются только после успешной обработки всей пачки (стратегия *at least once*).
    * Оптимизирован для минимизации сетевых запросов за счет параметров `FETCH_MIN_BYTES_CONFIG` и `MAX_POLL_RECORDS_CONFIG`.

## Принцип работы

1. **Запуск**: Продюсер при первой отправке регистрирует схему `MessageDto` в Registry.
2. **Передача**: Данные сериализуются в компактный бинарный формат Avro.
3. **Потребление**: Одиночный потребитель обрабатывает сообщения мгновенно, а пакетный ждет накопления 10 сообщений и фиксирует их прочтение после обработки всего пакета.
4. **Завершение**: Все компоненты поддерживают **Graceful Shutdown**, корректно закрывая соединения через `ShutdownHook` и метод `wakeup()`.

## Проверка и мониторинг

1. **Веб-интерфейс Kafka UI** ([http://localhost:8080](http://localhost:8080))
    *   **Сообщения:** визуальный контроль входящего потока данных.
    *   **Схемы:** просмотр автоматически созданной Avro-схемы для `MessageDto`.
    *   **Потребители:** мониторинг отставания (lag) и распределения партиций между репликами.
2. **Логи** (все ключевые этапы логируются в реальном времени)
    * `docker compose logs -f producer` — статус отправки и метаданные сообщений.
    * `docker compose logs -f single-consumer` — подтверждение мгновенной обработки.
    * `docker compose logs -f batch-consumer` — логи наполнения буфера и фиксации (commit) пачек.

## Стек технологий (2026)

| Категория | Технология |
| :--- | :--- |
| **Runtime** | Java 21 LTS (Source 17) |
| **Infrastructure** | Kafka 3.4 (KRaft-кластер из трех узлов), Confluent Schema Registry |
| **Orchestration** | Docker Compose + Healthchecks |
| **Serialization** | Avro 1.11.3 (Reflection mode) |
| **Monitoring** | [Kafka UI (порт 8080)](http://localhost:8080) |
| **Build** | Maven (Multi-stage build, Fat JAR) |
| **Logging** | SLF4J + Logback |

## Переменные окружения

* `BOOTSTRAP_SERVERS` — список адресов брокеров кластера.
* `SCHEMA_REGISTRY` — URL сервиса Schema Registry.
* `TOPIC` — имя целевого топика.
* `GROUP_ID` — идентификатор группы потребителей.
